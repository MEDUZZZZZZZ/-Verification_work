# **Проверочная работа по итогам первого блока**
## **Задача:**
Написать программу, которая из имеющегося массива строк формирует массив строк, длинна которых меньше либо равна 3 символа.
## **Для полного решения поставленной задачи необходимо было выполнить следующие условия:** 
> 1. Создать репозиторий на GitHub 
> 2. Нарисовать блок-схему алгоритма 
> 3. Снабдить репозиторий оформленным текстовым описанием решения (соответственно данный файл ReadMe.md)  
> 4. Написать программу решающую поставленную задачу
> 5. В процессе выполнения работы использовать контроль версий  

### Для реализации данной задачи мною был выбран язык программирования **Python**  
### 1. Формирование исходного массива  
На первом этапе было необходимо задать исходный массив строк, мной было принято решение формировать список путем ввода его элементов в консоль с клавиатуры.
Данная часть программы была реализована при помощи функции *list_filler*, которая представлена на избражении ниже:
![list_filler](/Verification_work/images/Verification_task_1.PNG)  
В этой функции формирование списка осуществляется в теле цикла **While** до тех пор, пока в консоль не будет подана "пустая" строка после чего флаг **stop** примет значение **1**. Добавление новых элементов в массив осуществляется при помощи встроенного в стандартную библиотеку языка Python метода списков **list.append(i)**, который в свою очередь добавляет элемент **i** в конец списка **list**. После выполнения функция возвращает список строк. 
### 2. Формирование массива строк с длинной не больше 3 символа  
Данная часть программы была реализована при помощи функции *find_less_then_tree*, которая представлена на изображении ниже.
![find_less_then_tree](/Verification_work/images/Verification_task_2.PNG)  
В качестве аргумента в данной функции может выступать список строк полученный в результате выполнения фнукции *list_filler* или же заданный на старте выполнения алгоритма. Для прохода по всем элементам массива используется цикл **for**, в теле которого происходит проверка на соответсвие длинны данного элемента заданному условию (не больше 3 символов). Если условие выполняется данный элемент при помощи ранее описанного метода списков **list.append(i)**, добавляется в новый список **result_list**, при невыполнении условия при помощи оператора **continue** цикл переходит на следующую итерациию. После выполнения функция возвращает список строк.   
### 3. Формирование строки для "красивого" вывода в консоль
Данная часть программы была реализована при помощи функции *print_list*, которая представлена на изображении ниже.
![print_list](/Verification_work/images/Verification_task_3.PNG)  
В качестве аргумента функции используется список полученный в результате выполнения функции *find_less_then_tree*, однако данная функция универсальна и в дальнейшем может быть использована для любых других одномерных списков. Для "красивого" вывода объявляется переменная text и ей присвается строка "[". Дальнейшее формирование строки осуществляется в цикле **for**. В заголовке цикла мы используем функцию **enumerate(list)**, которая позволяет на каждой итерации цикла получить кортеж состоящий из индекса элемента массива и самого элемента. Использование данной функции позволяет нам упростить реализацию проверки на последний элемент массива. Данная функция возвращает строку *text*, которая далее может быть вывведена в консоль.  
### 4. Програмный блок  
Непосредственно сама программа реализована следующим образом:  
![body](/Verification_work/images/Verification_task_4.PNG)  
### 5. Пример выполнения
![result](/Verification_work/images/Verification_task_5.PNG)  
### 6. Использование Git
Данная работа была загружена на удаленный репозиторий GitHub  
![Git](/Verification_work/images/Verification_task_6.PNG)  
Как видно из изображения, на момент написания файла ReadMe.md было выполенено 4 коммита.


